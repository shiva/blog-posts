---
title: Elixir - A crash course
categories:
  - programming languages
tags:
  - elixir
  - language
  - in a day
date: '2016-11-06'
slug: elixir-crash-course
description: Basics in Elixir, especially the deviations from the norm
---

This post is a set of points I noted down, as I read through the Elixir documentation. This is by no means comprehensive. This is meant to be a crash course for someone coming from years of C. 

All of the content here, is simply a parsed summary of what is available as part of the [official documentation][1].

## Types

### Atoms

Named contants with a value. `true` and `false` are atoms.

### Strings

- Supports unicode string natively! It's about time. 
- You can concatenate strings using `<>`. `"hello" <> " world"`.
- *CAUTION*: `byte_size("hellö") != String.length("hellö")`.
- *CAUTION*: (char list) `'hello' != "hello"` (string)


### Anonymous functions

Native support for closures -- called anonymous functions. Also, functions are first-class aka can be passed as arguments into other functions. Special syntax is required to invoke ananymous functions.

```
iex(1)> add = fn a,b -> a + b end
#Function<12.52032458/2 in :erl_eval.expr/5>
iex(2)> add.(1,2)
3
iex(3)> mulby2 = fn a -> add.(a,a) end
#Function<6.52032458/1 in :erl_eval.expr/5>
iex(4)> mulby2.(4)
8
iex(5)> 
```

### Lists

Native support for lists. hd(list) and tl(list). A list of printable characters will be output as a string. Slower linear access to data, but really fast to prepend elements to the list. eg. `[ 0 | list]`. 



### Tuples

Native support for associative arrays. Any pair of values, stored contiguously. Indexes start from zero. mutable `put_elem(tuple, idx, "value")`. Fast access, but expensive to add or insert elements

### Other types

Port, Reference and PID


## Operators

Note that ===, and !== use type when comparing (thankfully, the defaults are sensible)

  - +, - , ++, --, <> (concatenate)
  - and, or, not
  - &&, ||, !
  - ==, !=, === (more strict), !== (more strict), <=, >=, < and > 
  - nil/false == false (everything else is true)

### The match operator (`=`)

Used to assign result of an operation to a variable. Can also be used to assign a tuple or list to a set of variables. 

```
{a, b, c} = {:hello, "world", 42}
[a, b, c] = [1, 2, 3]
[head | tail] = [1, 2, 3]   # head = [1], tail = [2, 3]
```

### The pin operator (`^`)

Useful when there is a need to check one of the values of list, but assign another.

```
iex> x = 1
1
iex> x = 2
2
iex> x = 1
1
iex> ^x = 2
** (MatchError) no match of right hand side value: 2
```

### The _ operator

Ignore the rest, or assign the rest to _

iex> [h | _] = [1, 2, 3]
[1, 2, 3]
iex> h
1

## Control Structures (conditionals and loops)

case - check for multiple matches 
cond - check for multiple conditions
if - check for specific condition
unless - check for a specific match

Note: if and unless are macros and not first class constructs that are part of the language

Elixir allows a lot of variations of guards that are used in conditional to express conditions. See [here][2] for more information.


[1]: http://elixir-lang.org/getting-started/
[2]: http://elixir-lang.org/getting-started/case-cond-and-if.html#expressions-in-guard-clauses